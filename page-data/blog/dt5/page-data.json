{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/dt5/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"588f8229-431b-5020-ae78-ec5a8090bac2","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Trees\",\n  \"date\": \"2021-07-26\",\n  \"description\": \"Binary Trees,Binary Heap\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Tree\"), mdx(\"p\", null, \"Trees are the opposite of arrays and structures such as linked list hash tables, since the aforementioned are linear, and trees are not linear, since they can have 0 or more child nodes\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-60-l w-80\",\n    src: \"https://imgur.com/zCm3Wld.png\"\n  })), mdx(\"p\", null, \"A tree starts with a single node called root or a parent node and each child of the tree starts from this node we can notice in the previous example that a child node has only one parent node but a parent node can have several children, this relationship goes in one direction, it can go from parent to child or from child to parent.\"), mdx(\"p\", null, \"Trees are very important as they are used a lot in computer science every day\"), mdx(\"h3\", null, \"Ejemplo\"), mdx(\"p\", null, \"An example of trees is with the structure of html, although it is not a programming language you can see a similar structure to the trees.\\nIn Html we can say that the root node is the html tag this tag will have 2 children nodes that would be < body > and the < head > and so within these tags will have more children ... .\"), mdx(\"p\", null, \"Another example would be the comments of a web page where each comment can be answered with another comment.\"), mdx(\"h3\", null, \"Tipos\"), mdx(\"p\", null, \"There are a large number of tree types in computer science.\"), mdx(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/List_of_data_structures#Trees\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"You can see in wikipedia this amount\"), mdx(\"h2\", null, \"Binary Tree\"), mdx(\"p\", null, \"A binary tree is a Tree data structure that has to follow certain rules:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A node must have a maximum of 2 child nodes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A child node cannot have more than one parent\"))), mdx(\"p\", null, \"In the previous image we can see that this node is not a binary tree since node L has more than 2 children  \"), mdx(\"a\", {\n    href: \"https://visualgo.net/bn/bst\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"How does it work?\"), mdx(\"h3\", null, \"Types of binary tree\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-80-l w-100\",\n    src: \"https://imgur.com/t2zc7Mp.png\"\n  })), mdx(\"p\", null, \"You can consult how to identigy each node in \", mdx(\"a\", {\n    href: \"https://towardsdatascience.com/5-types-of-binary-tree-with-cool-illustrations-9b335c430254\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"this link\"), \".\"), mdx(\"p\", null, \"The one we are interesed in creating is the Perfect binary tree, since it has most interesting properties and is much more efficient than most.\"), mdx(\"p\", null, \"Some interesting properties\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"you can calculate the number by the height \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"2^h - 1\"))), mdx(\"h3\", null, \"Complexity of a Perfect binary tree\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-30-l w-60\",\n    src: \"https://imgur.com/0bqCCet.png\"\n  })), mdx(\"h3\", null, \"Binary tree unBalanced and Balanced\"), mdx(\"p\", null, \"These binary trees as seen in the image of the binary tree types are unbalanced. This is a problem with binary trees since they can take this form. When taking this form it will have a higher complexity.\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-40-l w-60\",\n    src: \"https://imgur.com/qDrawT7.png\"\n  })), mdx(\"p\", null, \"Since they will operate similar to a linked list.\"), mdx(\"h3\", null, \"When to use it?\"), mdx(\"p\", null, \"The binary tree as we can see, when it is a perfect binary tree is the fastest data structure in all operations. We van also see that it is ordered. Therefore it is easy to imagine where each node is and how the structure is set up. It has a flexible size.\"), mdx(\"p\", null, \"In general it is good to use it when we have data that fits in a balanced or perfect binary tree. (for example in a random list or in something relative)\"), mdx(\"h3\", null, \"When not to use it\"), mdx(\"p\", null, \"One of the disadvantages is that no operation has O(1) complexity so if we are only going to use a list to add an element or remove a last or firts element it is better to use another data structure like linked list or Arrays\"), mdx(\"h2\", null, \"Implement it\"), mdx(\"p\", null, \"It is easy to complement it, the difficult thing comes when an element is eliminated, since it has a structure a little difficult to understand.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Node():\\n    def __init__(self, data):\\n        self.data = data\\n        self.left = None\\n        self.right = None\\n\\n\\n\\nclass BST():\\n    def __init__(self):\\n        self.root = None\\n        self.number_of_nodes = 0\\n\\n\\n\\n    def insert(self, data):\\n        new_node = Node(data)\\n        if self.root == None:\\n            self.root = new_node\\n            self.number_of_nodes += 1\\n            return\\n        else:\\n            current_node = self.root\\n            while(current_node.left != new_node) and (current_node.right != new_node):\\n                if new_node.data > current_node.data:\\n                    if current_node.right == None:\\n                        current_node.right = new_node\\n                    else:\\n                        current_node = current_node.right\\n                elif new_node.data < current_node.data:\\n                    if current_node.left == None:\\n                        current_node.left = new_node\\n                    else:\\n                        current_node = current_node.left\\n            self.number_of_nodes += 1\\n            return\\n\\n\\n    def search(self,data):\\n        if self.root == None:\\n            return \\\"Tree Is Empty\\\"\\n        else:\\n            current_node = self.root\\n            while True:\\n                if current_node == None:\\n                    return \\\"Not Found\\\"\\n                if current_node.data == data:\\n                    return \\\"Found\\\"\\n                elif current_node.data > data:\\n                    current_node = current_node.left\\n                elif current_node.data < data:\\n                    current_node = current_node.right\\n\\n\\n    def remove(self, data):\\n        if self.root == None: \\n            return \\\"Tree Is Empty\\\"\\n        current_node = self.root\\n        parent_node = None\\n        while current_node!=None: \\n            if current_node.data > data:\\n                parent_node = current_node\\n                current_node = current_node.left\\n            elif current_node.data < data:\\n                parent_node = current_node\\n                current_node = current_node.right\\n            else: \\n                \\n                if current_node.right == None:\\n                    if parent_node == None:\\n                        self.root = current_node.left\\n                        return\\n                    else:\\n                        if parent_node.data > current_node.data:\\n                            parent_node.left = current_node.left\\n                            return\\n                        else:\\n                            parent_node.right = current_node.left\\n                            return\\n\\n                \\n                elif current_node.left == None:\\n                    if parent_node == None:\\n                        self.root = current_node.right\\n                        return\\n                    else:\\n                        if parent_node.data > current_node.data:\\n                            parent_node.left = current_node.right\\n                            return\\n                        else:\\n                            parent_node.right = current_node.right\\n                            return\\n\\n                \\n                elif current_node.left == None and current_node.right == None:\\n                    if parent_node == None:\\n                         current_node = None\\n                        return\\n                    if parent_node.data > current_node.data:\\n                        parent_node.left = None\\n                        return\\n                    else:\\n                        parent_node.right = None\\n                        return\\n\\n                elif current_node.left != None and current_node.right != None:\\n                    del_node = current_node.right\\n                    del_node_parent = current_node.right\\n                    while del_node.left != None: \\n                        del_node_parent = del_node\\n                        del_node = del_node.left\\n                    current_node.data = del_node.data \\n                    if del_node == del_node_parent: \\n                        current_node.right = del_node.right\\n                        return\\n                    if del_node.right == None: \\n                        del_node_parent.left = None\\n                        return\\n                    else: \\n                        del_node_parent.left = del_node.right\\n                        return\\n        return \\\"Not Found\\\"\\n\")), mdx(\"h2\", null, \"AVL Trees + Red Black Trees\"), mdx(\"p\", null, \"these are very similar and very useful to balance a binary Tree since what they do is when an element is added\\xF1ade o se elimina un elemento, cambiara el orden de los nodos para balancearlos. \"), mdx(\"h3\", null, \"AVL Tree\"), mdx(\"p\", null, \"The AVL tree takes its name from the initial of the sumames of its inventors, \", mdx(\"a\", {\n    href: \"https://es.wikipedia.org/wiki/Georgii_Adelson-Velskii\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"Georgii Adelson-Velskii\"), \" y \", mdx(\"a\", {\n    href: \"https://es.wikipedia.org/wiki/Yevgeniy_Landis\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"Yevgeniy Landis\"), \" . They made it known in the publication of an article in 1962, \\xABAn algorithm for the organization of information\\xBB .\"), mdx(\"p\", null, \"AVL trees are always balanced in such a way that for all nodes, the height of the left branch does not differ by more than one unit from the height of the right branch or vice versa. Thanks to this form of balancing, the complexity of a search in one of these trees is always kept in order of complexity O(log n).The balancing factor can be stored directly at each node or computed from the heights of the subtrees.\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-40-l w-60\",\n    src: \"https://imgur.com/5Y7Tg1Y.png\"\n  })), mdx(\"h3\", null, \"Red-black tree\"), mdx(\"p\", null, \"A red-black tree is an abstract type of data. Specifically, it is balanced binary search tree, a data structure used in computer science and informatics. The original structure was created by Rudoll Bayer in 1972, who gave it the name \\\"Symetric binary B-Trees\\\", but it took its modern name in a paper by Leo J.Guibas and Rober done in 1978. It is complex, but has a good worst-case runtime for its operations and is efficient in practice. It can search, insert, and delete in O(log n) time, where n is the list elemnts in the tree. \"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-40-l w-60\",\n    src: \"https://imgur.com/mIZSxLZ.png\"\n  })), mdx(\"h2\", null, \"Binary Heap\"), mdx(\"p\", null, \"Are a particular and simple case of the Tree data structure and is based on a Binary tree balanced, which can be seen as a binary tree with two additional constraints\"), mdx(\"a\", {\n    href: \"https://www.geeksforgeeks.org/binary-heap/\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"For more info\"), mdx(\"p\", null, \"This one, unlike the previous ones, is not ordered, so the search for an element will have a higher complexity.\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-30-l w-30\",\n    src: \"https://imgur.com/knWPFCt.png\"\n  })), \"Imagine you have a list of tasks to solve, but you want to sort them by importance. These problems are called prioty queues. To solve this problem you can put them in an array in order of importance, but adding an element or deleting it would be slow. To solve this we could do it with a linked list in the same way but although it is more efficient to add data than an array, seeing the less important tasks will be slow too. The best solution for this would be a binary heap.\", mdx(\"p\", null, \"What the binary heap does is to create a tree which is sorted in order.\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-30-l w-30\",\n    src: \"https://imgur.com/6iWZh6e.png\"\n  })), mdx(\"h3\", null, \"Implementation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import sys\\nclass MaxHeap:\\n\\n    def __init__(self, maxsize):\\n        self.maxsize = maxsize\\n        self.size = 0\\n        self.Heap = [0] * (self.maxsize + 1)\\n        self.Heap[0] = sys.maxsize\\n        self.FRONT = 1\\n\\n    def parent(self, pos):\\n        return pos // 2\\n\\n    def left_child(self, pos):\\n        return 2 * pos\\n\\n    def right_child(self, pos):\\n        return (2 * pos) + 1\\n\\n    def is_leaf(self, pos):\\n        if pos >= (self.size // 2) and pos <= self.size:\\n            return True\\n        return False\\n\\n    def swap(self, fpos, spos):\\n        self.Heap[fpos], self.Heap[spos] = self.Heap[spos], self.Heap[fpos]\\n\\n    def max_heapify(self, pos):\\n\\n        if not self.is_leaf(pos):\\n            if (self.Heap[pos] < self.Heap[self.left_child(pos)] or\\n                    self.Heap[pos] < self.Heap[self.right_child(pos)]):\\n\\n                if self.Heap[self.left_child(pos)] > self.Heap[self.right_child(pos)]:\\n                    self.swap(pos, self.left_child(pos))\\n                    self.max_heapify(self.left_child(pos))\\n\\n                else:\\n                    self.swap(pos, self.right_child(pos))\\n                    self.max_heapify(self.right_child(pos))\\n\\n    def insert(self, element):\\n        if self.size >= self.maxsize:\\n            return\\n        self.size += 1\\n        self.Heap[self.size] = element\\n        current = self.size\\n        while self.Heap[current] > self.Heap[self.parent(current)]:\\n            self.swap(current, self.parent(current))\\n            current = self.parent(current)\\n\\n    def print_heap(self):\\n        for i in range(1, (self.size // 2) + 1):\\n            print(\\\" PARENT : \\\" + str(self.Heap[i]) + \\\" LEFT CHILD : \\\" +\\n                  str(self.Heap[2 * i]) + \\\" RIGHT CHILD : \\\" +\\n                  str(self.Heap[2 * i + 1]))\\n\\n    def extract_max(self):\\n        popped = self.Heap[self.FRONT]\\n        self.Heap[self.FRONT] = self.Heap[self.size]\\n        self.size -= 1\\n        self.max_heapify(self.FRONT)\\n        return popped\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Trees","date":"2021-07-26","description":"Binary Trees,Binary Heap"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Distribution","date":"2021-11-01","description":"Data distributions"},"fields":{"slug":"/blog/est1/"}}},{"node":{"frontmatter":{"title":"Stats Testing","date":"2021-11-01","description":"Statistical Experiments and significance testing"},"fields":{"slug":"/blog/est2/"}}},{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}},{"node":{"frontmatter":{"title":"Sorting algorithms","date":"2021-08-26","description":"Bubble sort .o0"},"fields":{"slug":"/blog/alg2/"}}},{"node":{"frontmatter":{"title":"Algorithms Search","date":"2021-08-26","description":"BFS & DFS"},"fields":{"slug":"/blog/alg3/"}}}]}},"pageContext":{"slug":"/blog/dt5/","id":"588f8229-431b-5020-ae78-ec5a8090bac2"}},"staticQueryHashes":["63159454"]}