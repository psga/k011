{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/Compositions_of_functions/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"1b72e841-3b97-5c73-8654-3373d5975518","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Composition of functions\",\n  \"date\": \"2021-06-14\",\n  \"description\": \"composition, laws of composition and equipotence\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Composition\"), mdx(\"p\", null, \"Suppose we have \"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \" A \\\\xrightarrow {f} B \\\\xrightarrow {g} C\"), mdx(\"p\", null, \"two functions, so that the codomain of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f\"), \" coincides with the domain of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g\"), \". It is then possible to define a composite function \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g \\\\circ f\"), \" such that for all \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \" \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"(g \\\\circ f)(a)=g(f(a))\"), \".That is, as a set of pairs \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g \\\\circ f \\\\subseteq A \\\\times C is:\")), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"g \\\\circ f = {(a,c) \\\\in A \\\\times C \\\\; | \\\\; \\\\exist _{b \\\\in B} ((a,b) \\\\in f \\\\land (b,c) \\\\in g)} \"), mdx(\"p\", null, \"An elementary, and important ,property of composition is the associative property. If we have:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \" A \\\\xrightarrow {f} B \\\\xrightarrow {g} C \\\\xrightarrow {g} D\"), mdx(\"p\", null, \"Then, for all \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \" we have:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"(h \\\\circ g) \\\\circ f)(a) = (h \\\\circ g)(f(a))= h(g(f(a))= h \\\\circ (g \\\\circ f)(a)\"), mdx(\"p\", null, \"and therefore \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"(h \\\\circ g) \\\\circ f = h \\\\circ (g \\\\circ f)\")), mdx(\"p\", null, \"In every set \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" there is a special function ld\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"_{A}\"), \" that we call the identify in A. This function is the epitome of the non-action, it leaves everything as it was found.for every element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \" we have ld\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"_{A}\"), \". Two fundamental properties of the identify are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"f \\\\circ\"), \" \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ld\"), mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"_A=f\"), \" for any function f with domain \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"A\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ld\"), mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"_A \\\\circ f = f\"), \" for any function f with domain \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"A\"))), mdx(\"h2\", null, \"Inverse function\"), mdx(\"p\", null, \"With \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f : A \\\\to B\"), \" we can conclude that: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An inverse of f from the right is a function g such that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f \\\\circ g =\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ld\"), mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"_{B}\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An inverse of f from the left is a function h such that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"h \\\\circ f =\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ld\"), mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"_{A}\")))), mdx(\"p\", null, \"the only inverse function, on either side, of a bijective function f is called the inverse of f and is denoted by \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1}\")), mdx(\"p\", null, \"when we have partial functions \"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"f: A \\\\dashrightarrow B, \\\\;\\\\;\\\\; g: B \\\\dashrightarrow C\"), mdx(\"p\", null, \"then it is also possible to perform the composition, but note that the domain \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g \\\\circ f\"), \" may be smaller than the domain \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f\"), \". In general, we have :\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"dom(g \\\\circ f) = \\\\{ x \\\\in dom(f) \\\\; | \\\\; f(x)\\\\in dom(g) \\\\} =f^{*}(dom(g))\"), mdx(\"p\", null, \"Sometimes, if the range of f and the domain of g are disjoint, the composition has by domain \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\varnothing\"), \" and is the empty function\\nRecall that an injective function \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f: A \\\\to B\"), \" can always be seen as a bijective function if we reduce its codimension to ran(f). Por tanto cualquier funcion inyectiva f: A \\\\to B admits a partial inverse\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"f^{-1}:ran(f)\\\\to A\"), mdx(\"p\", null, \"in such a way that:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"f^{-1} \\\\circ f = \\\\text{ld}_{A},\\\\;\\\\;\\\\;\\\\; f \\\\circ f^{-1}= \\\\text{ld}_{ran(f)}\"), mdx(\"h2\", null, \"Laws of internal composition, semigrouping, groups\"), mdx(\"p\", null, \"let M be a set. An operation or law of internal composition on M is a function:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"\\\\star : M \\\\times M \\\\to M\"), mdx(\"p\", null, \"it is usual to represent symbolically the law of internal composition using a connective. That is, instead of writing \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\star (m,n)\"), \" we can write \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"m \\\\star n\")), mdx(\"p\", null, \"An example is when \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M\"), \" is a finite set, then an operation can be expressed by a table. by means of a table, For example, suppose \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M= \\\\{ a,b,c\\\\}\"), \". The following table:\"), mdx(\"center\", null, mdx(\"table\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, mdx(\"tr\", null, mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"\\u22C6\"), mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"a\"), mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"b\"), mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"c\")), mdx(\"tr\", null, mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"a\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"a\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"b\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"c\")), mdx(\"tr\", null, mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"b\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"b\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"c\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"b\")), mdx(\"tr\", null, mdx(\"th\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"c\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"c\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"a\"), mdx(\"td\", {\n    style: {\n      \"border\": \"1px solid white\"\n    }\n  }, \"b\")))), mdx(\"p\", null, \"It encodes the value of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"x\\\\star y\"), \",which we find if we look in the row corresponding to element x and the row corresponding to element y. x and the row corresponding to element y.\"), mdx(\"p\", null, \"We already know a whole series of operations on different sets, for example, addition, multiplication of integers, rational or real numbers. Multiplication of integers, rational or real numbers. Logic connectives can also be understood as operations on the set of well-formed formulas\"), mdx(\"p\", null, \"We should know that \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We say that the operation \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\star\"), \" on the set M is associative if for any elements a, b and c of M are satisfied:\")), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"(a \\\\star b) \\\\star c = a \\\\star (b \\\\star c)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An semigroup is a set M endowed with an associative operation \\\\star. Formally, the semigroup is usually referred to as M, and to over-understand the operation \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\star\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Let (\", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"M , \\\\star\"), \") be a semigroup. We say that \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"e \\\\in M\"), \" is a neutral element if verifies that for all \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"x \\\\in M\"), \" :\")), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"x \\\\star e = e \\\\star x = x\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We say that two elements m and n of a monoid M are inverses of each other if  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"m \\\\star n = e\"), \", the neutral element.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We say that two elements m and n of a moinoid M are inverses of each other if \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"m \\\\star n = n \\\\star m=  e\"), \", the neutral element of M. In such a case we say that m and n are invertible.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We say that a semigroup (\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M, \\\\star\"), \") is commutative if for any pair m, n of elements of M one has, for any pair m, n of elements of M one has,\"))), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"m \\\\star  n\\\\star =n \\\\star m\"), mdx(\"p\", null, \"given the above definitions, we can conclude several interesting facts \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"If a semigroup has a neutral element, it is unique.\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Proof\"), \". Suppose that e and u are two neutral elements of the semigroup M. Then \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"e \\\\star u = e\"), \", since  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"e\"), \" is a neutral element. Moreover \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"e \\\\star u = u\"), \", because u is a neutral element. That is, \"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"e=e\\\\star u= e\"), mdx(\"p\", null, \"and therefore all the neutral elements that could be in M are equal to each other\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"if m is invertible, its inverse is unique\"), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Proof\"), \". Let \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"n_{1}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"n_{2}\"), \" be two inverses of m. We have then,\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"m \\\\star n_{1} = e= m \\\\star n_{2}\"), mdx(\"p\", null, \"Operating on the elements of this identity with n1 from the left, we obtain:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"(n_{1} \\\\star m) \\\\star n_{1} = (n_{1} \\\\star m) \\\\star n_{2}\"), mdx(\"p\", null, \"and from there,\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"n_{1}=n_{2}\"), mdx(\"p\", null, \"Given any monoid (\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M , \\\\star\"), \"), we can always find a group within it as follows. The set of its invertible elements is nonempty, since it always has at least one identity element.The subset (\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M, \\\\star\"), \"), endowed with the operation \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\star\"), \" restricted to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M\\\\star\"), \", is a group. Which we call the unit group of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M\")), mdx(\"p\", null, \"Another thing is that given any monoid (\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M,\\\\star\"), \"), we can always find a group within it as follows. as follows. The set of its invertible elements is noneempty, since it always has at leat the identify element.iThe subset \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M\\\\star\"), \", endowed with the operation \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\star\"), \" restricted to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M\\\\star\"), \" is a group, wich we call the unit group of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"M\"), \". \"), mdx(\"p\", null, \"The concept of invertible element in a monoid is precisely a generalization of the concept of invertible function. A function \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f: X\\\\to X\"), \" is an invertible element of the monoid $F(X,x) if and only if it is an invertible function, if only if is a bijective function. The inverse element of f is nothing else than the inverse function.\"), mdx(\"p\", null, \"the set Biy\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"(X)\"), \" of all invertible functions of X on X is then the unit group of F(X,X). units of F(X,X). If X has at least 3 elements, Biy(X) is a noncommutative group\"), mdx(\"h3\", null, \"Morphism\"), mdx(\"p\", null, \"A morphism between \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"(M,\\\\star)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"(N,\\\\cdot)\"), \"  is a function,\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"\\\\varphi :  M \\\\to N\"), mdx(\"p\", null, \"wich has the property that for any \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"m\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"m'\"), \" elements of M, one has:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"\\\\varphi (m\\\\star n)=  \\\\varphi (m) \\\\cdot \\\\varphi (n)  \"), mdx(\"p\", null, \"if in addition \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\varphi\"), \" is bijective we say that M is an isomorphism\"), mdx(\"p\", null, \"Depending on wheter the structures in question are semigroups, monoids or groups, we can speak of semigroup, monoid or group morphisms. Morphisms of semigroupsm, monoids or groups\"), mdx(\"h4\", null, \"Carley theorem\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Let G be a group. Then G is isomorphic to a semigroup of\"), \" Biy \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(G).\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Proof\"), \" Let's define a morphism:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"L:G \\\\to \\\\text{Biy}(G)\"), mdx(\"p\", null, \"as follows: for any g and h of G,\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"L(g)(h)= g \\\\star h\"), \" isuffices now to prove that this morphism is injective\"), mdx(\"p\", null, \"Since the elements of Biy(X) are functions of X in X, the subgroups of Biy(X) are called groups of transformations. of X in X, the subgroups of Biy(X) are called groups of transformations. In a sense, we can say that the groups of transformations are concrete manifestations of the notation of group abstactness.Cayley's theorem tells us that every group is isomorphic to a group of transformations. It also tells us that every finite group with n different elements, is isomorphic to a subgroup of the symmetric group of n letters.\"), mdx(\"h2\", null, \"Set equipotence\"), mdx(\"p\", null, \"We say that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are equipotent if there exists a bijective function between \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \".\\nA and B. We write in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"|A| = |B|\"), \".\"), mdx(\"p\", null, \"It is clear that if \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are finite, then they are equipotent if and only if they have the same number of elements. In general, another way to express that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are equipotent is by the phrase \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" have the same cardinal.\"), mdx(\"p\", null, \"Similarly, we know that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" is minuspotent to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" if there exists an injective function of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" on \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \", in which case we write \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"|A| \\u2264 |B|\"), \". If in addition \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are not equipotent, we write   \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"|A| < |B|\"), \".\"), mdx(\"p\", null, \"Another way of expressing that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" is minuspotent to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are equipotent is by the phrase \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" has cardinal less than or equal to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \". Again, this phrase will make sense later, until we have accepted the principle of good order we will not be able to show that all sets are comparable to each other, that is, that given two sets \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" then one of them must have cardinality less than or equal to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \".\"), mdx(\"p\", null, \"if \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" is not empty and there is an injective function f: \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f: A \\\\to B\"), \" then there is an overjective funcion \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g:A \\\\to A\"), \" and we can prove this as follows:\"), mdx(\"p\", null, \"If A is not empty then we can choose an element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \". We define then:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"f(x)= \\\\left\\\\{ \\\\begin{array}{lcc}  \\nf^{-1}(x) & si & x \\\\in ran(f) \\\\\\\\  \\n\\\\\\\\ a & si & x \\\\notin ran(f)\\n\\\\end{array}  \\n\\\\right.\"), mdx(\"p\", null, \"thus g is overjective and with that we can see the Cantor-Schr theorem \\u0308oder-Bernstein:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Theorem\"), \".  \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Suppose that there are injective functions \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"inlineMath\"\n  }, \"f:A\\\\to B\"), \" and \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"inlineMath\"\n  }, \"g: B\\\\to A\"), \". Then there is a bijective function: \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"inlineMath\"\n  }, \"F: A\\\\to B\"))), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Proof\"), \" .\\nWe consider the inverse functions \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1} : f(A) \\\\xrightarrow{\\\\sim} B\"), \" y \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g^{-1} : g(B) \\\\xrightarrow{\\\\sim} A\"), \"\\nFor each element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \" we define a finite or infinite sequence \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a_{0},a_{1},a_{2},a_{3},...\"), \" of elements alternating A and B as follows \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Elements to wich corresponds a sequence that never ends\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Elements that generate a finite sequence with an odd number of terms that terminates in an element A that does not belong to g(B)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Elements that generate a finite sequence with an even number of terms that terminates in an element of B that does not belong to g(B)\"))), mdx(\"p\", null, \"It is clear that these three possibilities are mutually exclusive. We call \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A'\"), \" the subset of the elements of a that verify condition (c) above. Let us first note that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A' \\\\sube g(B)\"), \" since if the sequence starting with a terminates in an element of B then it is because it was at least possible to take the first step. This allow us to define by a function \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"F: A \\\\to B\"), \" by means of the formula\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"F(x)= \\\\left\\\\{ \\\\begin{array}{lcc}  \\ng^{-1}(x) & si & x \\\\in A' \\\\\\\\  \\n\\\\\\\\ f(x) & si & x \\\\notin A'\\n\\\\end{array}  \\n\\\\right.\"), mdx(\"p\", null, \"Let us see that F is overjective. Consider any element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"b \\\\in B\"), \". There are two possibles cases, \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"b \\\\notin f(A)\"), \" or \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"b \\\\in f(A)\"), \". Let us consider the first case. If \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"b \\\\notin f(A)\"), \" the sequence corresponding to the elemnt \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b)\\\\in A\"), \" has only two termins:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"g(b),b\"), mdx(\"p\", null, \"since it is no longer possible to apply \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1}\"), \" to b.This implies that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\in A'\"), \" and in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"F(g(b))=g^{-1}(g(b))=b\"), \". Let us consider the second case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"b \\\\in f(A)\"), \". examine now the element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\in A\"), \", the sequence that corresponds to it has three terms, and may eventually be infinite \"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"g(b),b,f^{-1}(b), ...\"), mdx(\"p\", null, \"Again there are two possibilities, \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b)\\\\in A'\"), \" (which corresponds to a finite sequence ending in B) and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\notin A'\"), \". in the first case, we have f(g(b))=b. In the second case, \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\notin A'\"), \" let us note that the sequence corresponding to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1} (b)\"), \" is the same as that of g(b), but without the first two terms. Therefore, in that case we also have \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1}(b) \\\\notin A'\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"F(f^{-1}(b))=b\"), \". In either case we have found an element of a whose image by F is b and we can ensure that F is overjective\"), mdx(\"p\", null, \"Let us see that F is injective. Let a and a' two elements of A having the same image b= F(a)=F(a). There are three mutually exclusive possibilities.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"a and a are both in the set A'. in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g^{-1}(a)=g^{-1}(a')\"), \" and since \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g^{-1}\"), \" is a bijection between \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(B)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" we have that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a=a'\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"a and a' are both outside \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A'\"), \". in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f(a)=f(a')\"), \" and since f is injective we get \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a = a\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"One of them is in \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A'\"), \" and the other is outside \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \". Let us see that this case is not possible, and assuming it leads to contradiction. Without loss of generality let us consider \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\notin A'\"), \" and  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a' \\\\in A'\"), \". That means \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f(a) = g^{-1}(a')=b\"), \". let us consider the sequence corresponding to the element a. This is,\"))), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"a',b,a,...\"), mdx(\"p\", null, \" That is the sequence of a is the sequence of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a'\"), \"  eliminating the first two terms. Since the element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a'\"), \" corresponds to a finite sequence that ends in an element of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \", the element a, must have the same ocurrence, and therefore \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A'\"), \", in contradiction with our hypotesis \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\notin A'\"), \". We have seen then that in the first two cases \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a = a'\"), \" and that the third case cannot occur. Therefore F is injective.\"), mdx(\"p\", null, \"Thanks to the Cantor-Schroder-Bernstein theorem, we can compare the size of the conjunctions.\\nc conjuncts.\"), mdx(\"h1\", null, \"Equipotent\"), mdx(\"p\", null, \"We say that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are equipotent if there exists a bijective function between \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \".\\nA and B. We write in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"|A| = |B|\"), \".\\nIt is clear that if \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are finite, then they are equipotent if and only if they have the same number of elements. In general, another way to express that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are equipotent is by the phrase \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" have the same cardinal.\"), mdx(\"p\", null, \"Similarly, we know that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" is minuspotent to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" if there exists an injective function of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" on \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \", in which case we write \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"|A| \\u2264 |B|\"), \". If in addition \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are not equipotent, we write   \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"|A| < |B|\"), \".\\nAnother way of expressing that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" is minuspotent to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" are equipotent is by the phrase \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" has cardinal less than or equal to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \". Again, this phrase will make sense later, until we have accepted the principle of good order we will not be able to show that all sets are comparable to each other, that is, that given two sets \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \" then one of them must have cardinality less than or equal to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \".\"), mdx(\"p\", null, \"if \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" is not empty and there is an injective function f: \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f: A \\\\to B\"), \" then there is an overjective funcion \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g:A \\\\to A\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"and we can prove this as follows:\\nIf A is not empty then we can choose an element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \". We define then:\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"f(x)= \\\\left\\\\{ \\\\begin{array}{lcc}  \\nf^{-1}(x) & si & x \\\\in ran(f) \\\\\\\\  \\n\\\\\\\\ a & si & x \\\\notin ran(f)\\n\\\\end{array}  \\n\\\\right.\"), mdx(\"p\", null, \"thus g is overjective and with that we can see the Cantor-Schr theorem \\u0308oder-Bernstein:\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Theorem\"), \".  \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Suppose that there are injective functions \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"inlineMath\"\n  }, \"f:A\\\\to B\"), \" and \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"inlineMath\"\n  }, \"g: B\\\\to A\"), \". Then there is a bijective function: \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"inlineMath\"\n  }, \"F: A\\\\to B\")), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Proof\"), \"\\nWe consider the inverse functions \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1} : f(A) \\\\xrightarrow{\\\\sim} B\"), \" y \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g^{-1} : g(B) \\\\xrightarrow{\\\\sim} A\"), \"\\nFor each element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A\"), \" we define a finite or infinite sequence \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a_{0},a_{1},a_{2},a_{3},...\"), \" of elements alternating A and B as follows \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elements to wich corresponds a sequence that never ends\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elements that generate a finite sequence with an odd number of terms that terminates in an element A that does not belong to g(B)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elements that generate a finite sequence with an even number of terms that terminates in an element of B that does not belong to g(B)\")), mdx(\"p\", null, \"It is clear that these three possibilities are mutually exclusive. We call \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A'\"), \" the subset of the elements of a that verify condition (c) above. Let us first note that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A' \\\\sube g(B)\"), \" since if the sequence starting with a terminates in an element of B then it is because it was at least possible to take the first step. This allow us to define by a function \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"F: A \\\\to B\"), \" by means of the formula\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"F(x)= \\\\left\\\\{ \\\\begin{array}{lcc}  \\ng^{-1}(x) & si & x \\\\in A' \\\\\\\\  \\n\\\\\\\\ f(x) & si & x \\\\notin A'\\n\\\\end{array}  \\n\\\\right.\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"g(b),b\"), mdx(\"p\", null, \"since it is no longer possible to apply \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1}\"), \" to b.This implies that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\in A'\"), \" and in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"F(g(b))=g^{-1}(g(b))=b\"), \". Let us consider the second case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"b \\\\in f(A)\"), \". examine now the element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\in A\"), \", the sequence that corresponds to it has three terms, and may eventually be infinite \"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"g(b),b,f^{-1}(b), ...\"), mdx(\"p\", null, \"Again there are two possibilities, \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b)\\\\in A'\"), \" (which corresponds to a finite sequence ending in B) and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\notin A'\"), \". in the first case, we have f(g(b))=b. In the second case, \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(b) \\\\notin A'\"), \" let us note that the sequence corresponding to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1} (b)\"), \" is the same as that of g(b), but without the first two terms. Therefore, in that case we also have \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f^{-1}(b) \\\\notin A'\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"F(f^{-1}(b))=b\"), \". In either case we have found an element of a whose image by F is b and we can ensure that F is overjective\\nLet us see that F is injective. Let a and a' two elements of A having the same image b= F(a)=F(a). There are three mutually exclusive possibilities.\"), mdx(\"p\", null, \"1) a and a are both in the set A'. in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g^{-1}(a)=g^{-1}(a')\"), \" and since \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g^{-1}\"), \" is a bijection between \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"g(B)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \" we have that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a=a'\")), mdx(\"p\", null, \"2) a and a' are both outside \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A'\"), \". in that case \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f(a)=f(a')\"), \" and since f is injective we get \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a = a\")), mdx(\"p\", null, \"3) One of them is in \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A'\"), \" and the other is outside \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"A\"), \". Let us see that this case is not possible, and assuming it leads to contradiction. Without loss of generality let us consider \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\notin A'\"), \" and  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a' \\\\in A'\"), \". That means \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"f(a) = g^{-1}(a')=b\"), \". let us consider the sequence corresponding to the element a. This is,\"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"a',b,a,...\"), mdx(\"p\", null, \" That is the sequence of a is the sequence of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a'\"), \"  eliminating the first two terms. Since the element \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a'\"), \" corresponds to a finite sequence that ends in an element of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"B\"), \", the element a, must have the same ocurrence, and therefore \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\in A'\"), \", in contradiction with our hypotesis \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a \\\\notin A'\"), \"\\nWe have seen then that in the first two cases \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a = a'\"), \" and that the third case cannot occur.\\nTherefore F is injective.\\nThanks to the Cantor-Schroder-Bernstein theorem, we can compare the size of the conjunctions.\\nc conjuncts.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Composition of functions","date":"2021-06-14","description":"composition, laws of composition and equipotence"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"RSA","date":"2021-08-14","description":"Modular arithmetic, cryptography"},"fields":{"slug":"/blog/RSA/"}}},{"node":{"frontmatter":{"title":"what happens when we access a webpage","date":"2021-07-26","description":"ka"},"fields":{"slug":"/blog/backend_1/"}}},{"node":{"frontmatter":{"title":"Array Data Structures","date":"2021-07-26","description":"Arrays Data Structures"},"fields":{"slug":"/blog/dt1/"}}},{"node":{"frontmatter":{"title":"Hash tables Data Structures","date":"2021-07-26","description":"Hash tables Data Structures"},"fields":{"slug":"/blog/dt2/"}}},{"node":{"frontmatter":{"title":"Big O","date":"2021-07-16","description":"Simetry and Asymetry cryptoghy. Tokens "},"fields":{"slug":"/blog/BigO/"}}}]}},"pageContext":{"slug":"/blog/Compositions_of_functions/","id":"1b72e841-3b97-5c73-8654-3373d5975518"}},"staticQueryHashes":["63159454"]}