{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/dt1/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"f47c9944-e779-56a5-b3eb-a1d1f8f6bf38","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Array Data Structures\",\n  \"date\": \"2021-07-26\",\n  \"description\": \"Arrays Data Structures\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Array\"), mdx(\"p\", null, \"An array is a way to store data of the same type or class (integers, characters, Boolean, etc.), although in some languages data of different classes can be stored.\\neach element is enumerated with its index. With this you can easily access an array element only with its index.\\nthe enumeration of these elements within the array starts from 0 in most languages and this implies that it ends at n-1 (where n is the size of the array, the number of elements). For this reason it is said that in programming we start counting from 0.\\nThe array is probably the simplest and most widely used data structure.\"), mdx(\"p\", null, \"In python you can declare\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"array=[\\\"1\\\",\\\"2\\\",\\\"3\\\"]\\n# ind:  0   1   2\\n\")), mdx(\"p\", null, \"you can access an object with its index, for example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"array[1]\\n#output: 2\\n\")), mdx(\"p\", null, \"There are several methods that can be used in an array. here are some of them\"), mdx(\"h3\", null, \"append\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"array.append(\\\"4\\\") #O(1)\\n\")), mdx(\"p\", null, \"This method will add an element to the end of the list. this will not change the indixes of the other elements.so it will have a complexity of 1 because \"), mdx(\"h3\", null, \"pop\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"array.pop() #O(1)\\n\")), mdx(\"p\", null, \"This method will remove the last item from the list, and like the previous method, this will not change the indexes of the other items, so it will have a complexity of 1 since it will have a complexity of 1.\\nso it will have a complexity of 1 because\\nAlthough pop will also delete an element if we give it the index as parameter \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"array.pop(2) #O(n)\\n\")), mdx(\"p\", null, \"But it will no longer have a complexity of 1. It will be n\"), mdx(\"h3\", null, \"insert\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"array.insert(0,\\\"0\\\")#O(1)\\n\")), mdx(\"p\", null, \"This method will insert the \\\"0\\\" at the top of the list but will move all other items to the right 1 index. This will make the complexity n (the size of the list)\"), mdx(\"p\", null, \"there are many more methods that we can find like max, min, sort that can be seen in the \", mdx(\"a\", {\n    href: \"https://wiki.python.org/moin/TimeComplexity\"\n  }, \"python wiki\"), \" \"), mdx(\"h2\", null, \"how an array is constructed\"), mdx(\"hr\", null), mdx(\"p\", null, \"To better understand how it is constructed we can make one\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class my_array():\\n    def __init__(self):\\n        self.length = 0\\n        self.data = {} \\n\\n    def __str__(self):\\n       return str(self.__dict__) \\n\\n    def get(self, index):\\n        return self.data[index] \\n\\n    def push(self, item):\\n        self.data[self.length] = item\\n        self.length += 1\\n\\n    def pop(self):\\n        self.length -= 1            \\n        last_item = self.data[self.length]  \\n        del self.data[self.length]      \\n        return last_item            \\n\\n    def insert(self, index, item):\\n        for i in range(self.length, index, -1):\\n            self.data[i] = self.data[i-1] \\n        self.length += 1\\n        self.data[index] = item       \\n\\n\\n    def delete(self,index):\\n        for i in range(index, self.length-1):\\n            self.data[i] = self.data[i+1]   \\n        del self.data[self.length - 1]      \\n        self.length -= 1            \\n\")), mdx(\"h2\", null, \"Code example\"), mdx(\"hr\", null), mdx(\"p\", null, \"we can see an example code that consists of merging 2 arrays and sorting them.\\nThere are many ways to do this, the simplest way is to add the arrays and sort them:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def merge_arrays(arr1, arr2):\\n    return sorted(set(arr1+arr2))\\n\")), mdx(\"p\", null, \"but this is not the fastest way to do it, since it is sorted after the addition, the best and fastest way would be that when the array is merged, it is already sorted. And this would be done by sorting it while merging it.\\nthat way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def merge(array1, array2):\\n    new_array = []\\n    flag = 0\\n    first_array_index = second_array_index = 0\\n    while not (first_array_index>=len(array1) or second_array_index>=len(array2)):\\n        if array1[first_array_index] <= array2[second_array_index]:\\n            new_array.append(array1[first_array_index])\\n            first_array_index += 1\\n        else:\\n            new_array.append(array2[second_array_index])\\n            second_array_index += 1\\n\\n        if first_array_index==len(array1): \\n            flag = 1 \\n\\n    if flag == 1: \\n        for item in array2[second_array_index:]:\\n            new_array.append(item)\\n    else: \\n        for item in array1[first_array_index:]:\\n            new_array.append(item)\\n\\n    return new_array\\n\\n\")), mdx(\"h2\", null, \"Pros and cons\"), mdx(\"hr\", null), mdx(\"h3\", null, \"Pros:\"), mdx(\"p\", null, \"We can see that the pros of using this structure is that it has an index and this makes it quick to see any item, and it is also the best options for sorting. We can see that it is quick to remove the last item and add an item at the end (pop and push).\"), mdx(\"h3\", null, \"Cons:\"), mdx(\"p\", null, \"It is a bit slow to insert or delete an item(since the index of the items that follow after the deleted item or the item to be added must be moved) likewise with deleting an item.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Array Data Structures","date":"2021-07-26","description":"Arrays Data Structures"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}},{"node":{"frontmatter":{"title":"RSA","date":"2021-08-14","description":"Modular arithmetic, cryptography"},"fields":{"slug":"/blog/RSA/"}}},{"node":{"frontmatter":{"title":"what happens when we access a webpage","date":"2021-07-26","description":"ka"},"fields":{"slug":"/blog/backend_1/"}}},{"node":{"frontmatter":{"title":"Array Data Structures","date":"2021-07-26","description":"Arrays Data Structures"},"fields":{"slug":"/blog/dt1/"}}},{"node":{"frontmatter":{"title":"Hash tables Data Structures","date":"2021-07-26","description":"Hash tables Data Structures"},"fields":{"slug":"/blog/dt2/"}}}]}},"pageContext":{"slug":"/blog/dt1/","id":"f47c9944-e779-56a5-b3eb-a1d1f8f6bf38"}},"staticQueryHashes":["63159454"]}