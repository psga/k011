{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/dt4/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"462d81dd-5a81-5202-be05-0f2a3656fc59","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stacks+ queues\",\n  \"date\": \"2021-07-26\",\n  \"description\": \"Linked list Data Structures\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Stacks\"), mdx(\"p\", null, \"This data structure is an ordered list that allows to store and retrieve data. This ordered list works by LIFO (Last In, First Out). The analogy of a stack of dishes is often used and refers to putting dishes on top of each other.\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-40-l w-60\",\n    src: \"https://i.imgur.com/oRnVwt3.png\"\n  })), mdx(\"p\", null, \"This term is not only used in computing, it is also used in storage management of any kind.\"), mdx(\"p\", null, \"Stacks can be implemented from Arrays and linked List.\"), mdx(\"p\", null, \"Let' see the implementation with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Linked list\"), \" \"), mdx(\"p\", null, \"The functions that in general are used in stacks are: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lookup: See the list content \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"peek: this return top element of the list \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"push: This inserts an element in top of the list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pop : This removes top element from the list\")), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-20-l w-50\",\n    src: \"https://i.imgur.com/kGQPkn0.png\"\n  })), mdx(\"h3\", null, \"Linked list implementation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Stack():\\n    def __init__(self):\\n        self.top = None\\n        self.bottom = None\\n        self.length = 0\\n\\n    def peek(self):\\n        if self.top is None:\\n            return None\\n        return self.top.data\\n\\n    def push(self, data):\\n        new_node = Node(data)\\n        if self.top == None:\\n            self.top = new_node\\n            self.bottom = new_node\\n        else: \\n            new_node.next = self.top\\n            self.top = new_node\\n        self.length += 1\\n\\n    def pop(self):\\n        if self.top == None: \\n            print(\\\"Stack empty\\\")\\n        else:\\n            self.top = self.top.next\\n            self.length -= 1\\n            if(self.length == 0):\\n                self.bottom = None\\n\\n    def print_stack(self):\\n        if self.top == None:\\n            print(\\\"Stack empty\\\")\\n        else:\\n            current_pointer = self.top\\n            while(current_pointer!=None):\\n                print(current_pointer.data)\\n                current_pointer = current_pointer.next\\n\")), mdx(\"h3\", null, \"Stack with Arrays\"), mdx(\"p\", null, \"Stacks can be used with arrays, as they are very simple and works somewhat similar with respect to algorithmic complexity\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Stack():\\n    def __init__(self):\\n        self.array = []\\n\\n    def peek(self):\\n        return self.array[len(self.array)-1]\\n\\n    def push(self, data):\\n        self.array.append(data)\\n        return\\n\\n    def pop(self):\\n        if len(self.array)!= 0:\\n            self.array.pop()\\n            return\\n        else:\\n            print(\\\"Stack Empty\\\")\\n            return\\n\\n    def print_stack(self):\\n        for i in range(len(self.array)-1, -1, -1):\\n            print(self.array[i])\\n        return\\n\")), mdx(\"h1\", null, \"Queues\"), mdx(\"p\", null, \"This data structure is an ordered list that, like the stacks, allows to store and manage data. This data structure follos the FIFO (\\\"First in, First Out\\\") method.\"), mdx(\"p\", null, \"A good analogy for this is the rows of people \"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-20-l w-50\",\n    src: \"https://i.imgur.com/yixXDnT.png\"\n  })), mdx(\"p\", null, \"Where the first in is served first.\"), mdx(\"p\", null, \"The general functions used by queues are\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lookup: View the contents of the list \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"enqueue: This will add an element to the end of the list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dequeue: This will remove the first element\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"peek: Returns the first in the list\")), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-20-l w-50\",\n    src: \"https://i.imgur.com/kGQPkn0.png\"\n  })), mdx(\"p\", null, \"This is generally not implemented with arrays since we know that removing or adding an element to the beginning of the list has a complexity of n so it is mostly implemented with linkedlist:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Queue():\\n\\n    def __init__(self):\\n        self.first = None\\n        self.last = None\\n        self.length = 0\\n\\n    def peek(self):\\n        return self.first.data\\n\\n    def enqueue(self, data):\\n        new_node = Node(data)\\n        if self.last == None:\\n            self.last = new_node\\n            self.first = self.last\\n            self.length += 1\\n            return\\n        else:\\n            self.last.next = new_node\\n            self.last = new_node\\n            self.length += 1\\n            return\\n\\n    def dequeue(self):\\n        if self.last == None:\\n            print(\\\"Quue Empty\\\")\\n            return\\n        if self.last == self.first:\\n            self.last = None\\n        self.first = self.first.next\\n        self.length -= 1\\n        return\\n\\n    def print_queue(self):\\n        if self.length == 0:\\n            print(\\\"Queue Empty\\\")\\n            return\\n        else:\\n            current_pointer = self.first\\n            while(current_pointer!= None):\\n                if current_pointer.next == None:\\n                    print(current_pointer.data)\\n                else:\\n                    print(f'{current_pointer.data}  <<--  ', end='')\\n                current_pointer = current_pointer.next\\n            return\\n\")), mdx(\"h3\", null, \"Interesting note.\"), mdx(\"p\", null, \"One of the most interesting problems involving stacks or queues is to \", mdx(\"a\", {\n    href: \"https://leetcode.com/problems/implement-queue-using-stacks/description/\",\n    className: \"link  white hover-white-60\",\n    target: \"_blank\"\n  }, \"a queue with stacks\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Stacks+ queues","date":"2021-07-26","description":"Linked list Data Structures"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}},{"node":{"frontmatter":{"title":"Sorting algorithms","date":"2021-08-26","description":"Bubble sort .o0"},"fields":{"slug":"/blog/alg2/"}}},{"node":{"frontmatter":{"title":"Algorithms Search","date":"2021-08-26","description":"BFS & DFS"},"fields":{"slug":"/blog/alg3/"}}},{"node":{"frontmatter":{"title":"Dinamic Programming","date":"2021-08-26","description":"Memoization,fibonacci"},"fields":{"slug":"/blog/alg4/"}}},{"node":{"frontmatter":{"title":"RSA","date":"2021-08-14","description":"Modular arithmetic, cryptography"},"fields":{"slug":"/blog/RSA/"}}}]}},"pageContext":{"slug":"/blog/dt4/","id":"462d81dd-5a81-5202-be05-0f2a3656fc59"}},"staticQueryHashes":["63159454"]}