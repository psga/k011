{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/dt3/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"ec4395c6-9ec5-5c9f-95f1-43b75dbe0d5a","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Linked list\",\n  \"date\": \"2021-07-26\",\n  \"description\": \"Linked list Data Structures\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Linked List\"), mdx(\"p\", null, \"first we must know what a node is;\"), mdx(\"p\", null, \"the linked list is a dynamic data structure in which each element points to the next. the number of nodes in this list can grow and shrink, i.e. it is not fixed. This data structure is one of the simplest and most common, and it can be used to implement many other types of data (for example in hash tables). it has several advantages and disadvantages with respect to an array, but the main advantage of a linked list is that the elements of the list can be easily inserted or deleted without reassigning or reorganizing the whole structure.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"##Node\\nthe node that works in the linked list has 2 data, the value and the reference to the other node as shown in the picture\"), mdx(\"center\", null, mdx(\"img\", {\n    src: \"https://i.imgur.com/xMCPn2P.png\"\n  })), \"This is how it could be implemented\", mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Node():\\n    def __init__(self, data): \\n        self.data = data \\n        self.next = None \\n\")), mdx(\"h2\", null, \"Implementation linked list:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\nclass Node():\\n    def __init__(self, data): \\n        self.data = data \\n        self.next = None \\n\\n\\nclass LinkedList():\\n    def __init__(self):\\n        self.head = None\\n        self.tail = self.head\\n        self.length = 0\\n\\n    def append(self, data):\\n        new_node = Node(data)\\n        if self.head == None:\\n            self.head = new_node\\n            self.tail = self.head\\n            self.length = 1\\n        else:\\n            self.tail.next = new_node\\n            self.tail = new_node\\n            self.length += 1\\n\\n    def prepend(self, data):\\n        new_node = Node(data)\\n        if self.head == None:\\n            self.head = new_node\\n            self.tail = self.head\\n            self.length += 1\\n        else:\\n            new_node.next = self.head\\n            self.head = new_node\\n            self.length += 1\\n\\n    def print_list(self):\\n        if self.head == None:\\n            print(\\\"Empty\\\")\\n        else:\\n            current_node = self.head\\n            while current_node!= None:\\n                print(current_node.data, end= ' ')\\n                current_node = current_node.next\\n        print()\\n\\n    def insert(self, position, data):\\n        if position >= self.length:\\n            if position>self.length:\\n                print(\\\"This position is not available. Inserting at the end of the list\\\")\\n            new_node = Node(data)\\n            self.tail.next = new_node\\n            self.tail = new_node\\n            self.length += 1\\n        elif position == 0:\\n            new_node = Node(data)\\n            new_node.next = self.head\\n            self.head = new_node\\n            self.length += 1\\n        else:\\n            new_node = Node(data)\\n            current_node = self.head\\n            for i in range(position-1):\\n                current_node = current_node.next\\n            new_node.next = current_node.next\\n            current_node.next = new_node\\n            self.length += 1\\n\\n\\n    def delete_by_value(self, data):\\n        if self.head == None:\\n            print(\\\"Linked List is empty. Nothing to delete.\\\")\\n            return\\n        current_node = self.head\\n        if current_node.data == data:\\n            self.head = self.head.next\\n            if self.head == None or self.head.next==None:\\n                self.tail = self.head\\n            self.length -= 1\\n            return\\n        while current_node.next!= None and current_node.next.data != data:\\n            current_node = current_node.next\\n        if current_node.next!=None:\\n            current_node.next = current_node.next.next\\n            if current_node.next == None:\\n                self.tail = current_node\\n            self.length -= 1\\n            return\\n        else:\\n            print(\\\"Given value not found.\\\")\\n\\n    def delete_by_position(self, position):\\n        if self.head == None:\\n            print(\\\"Linked List is empty. Nothing to delete.\\\")\\n            return\\n        if position == 0:\\n            self.head = self.head.next\\n            if self.head == None or self.head.next == None:\\n                self.tail = self.head\\n            self.length -= 1\\n            return\\n        if position>=self.length:\\n            position = self.length-1\\n        current_node = self.head\\n        for i in range(position - 1):\\n            current_node = current_node.next\\n        current_node.next = current_node.next.next\\n        self.length -= 1\\n        if current_node.next == None:\\n            self.tail = current_node\\n        return\\n\")), mdx(\"h1\", null, \"Doubly Linked List\"), mdx(\"p\", null, \"Unlike a normal linked list in which in each node there was a reference to the next node in a doubly linked list in each node there are 2 references, one to the next node and one to the previous one.\\nBy having 2 references it spends more memory and although it has the same algorithmic complexity it can be seen that it is a little faster in some aspects, since for example to arrive to the penultimate element instead of going through almost the whole list it will only go through the last one.\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-60-l w-100\",\n    src: \"https://i.imgur.com/n3SkmOc.png\"\n  })), \"the only thing that would have to be done to implement the above list and turn it into a Doubly linked list would be to add a new property to the node and change a little the functions of the classes to notice the difference between a doublyLinkedList and a LinkedList. So we can make a doubly linked list just by having the previous linked list. So:\", mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class DoublyLinkedList():\\n    def __init__(self):\\n        self.head = None\\n        self.tail = self.head\\n        self.length = 0\\n\\n    def print_list(self):\\n        if self.head == None:\\n            print(\\\"Empty\\\")\\n        else:\\n            current_node = self.head\\n            while current_node!= None:\\n                print(current_node.data, end= ' ')\\n                current_node = current_node.next\\n        print()\\n\\n\\n    def append(self, data):\\n        new_node = Node(data)\\n        if self.head == None: \\n            self.head = new_node\\n            self.tail = self.head\\n            self.length += 1\\n            return\\n        else: \\n            new_node.previous = self.tail\\n            self.tail.next = new_node \\n            self.tail = new_node \\n            self.length += 1\\n            return\\n\\n    def prepend(self, data):\\n        new_node = Node(data)\\n        if self.head == None:\\n            self.head = new_node\\n            self.tail = self.head\\n            self.length += 1\\n            return\\n        else:\\n            new_node.next = self.head \\n            self.head.previous = new_node \\n            self.head = new_node \\n            self.length += 1\\n            return\\n\\n\\n    def insert(self, position, data):\\n        if position == 0:\\n            self.prepend(data) \\n            return\\n        if position >= self.length:\\n            self.append(data) \\n            return\\n        else:\\n            new_node = Node(data)\\n            current_node = self.head\\n            for i in range(position - 1): \\n                current_node = current_node.next\\n            new_node.previous = current_node \\n            new_node.next = current_node.next \\n            current_node.next = new_node \\n            new_node.next.previous = new_node \\n            self.length += 1\\n            return\\n\\n\\n    def delete_by_value(self, data):\\n        if self.head == None:\\n            print(\\\"Linked List is empty. Nothing to delete.\\\")\\n            return\\n\\n        current_node = self.head\\n        if current_node.data == data:\\n            self.head = self.head.next\\n            if self.head == None or self.head.next==None: \\n                self.tail = self.head\\n            if self.head != None:\\n                self.head.previous = None \\n            self.length -= 1\\n            return\\n        try:  \\n            while current_node!= None and current_node.next.data != data:\\n                current_node = current_node.next\\n            if current_node!=None:\\n                current_node.next = current_node.next.next\\n                if current_node.next != None: \\n                    current_node.next.previous = current_node \\n                else:\\n                    self.tail = current_node \\n                self.length -= 1\\n                return\\n        except AttributeError:\\n            print(\\\"Given value not found.\\\")\\n            return\\n\\n\\n    def delete_by_position(self, position):\\n        if self.head == None:\\n            print(\\\"Linked List is empty. Nothing to delete.\\\")\\n            return\\n\\n        if position == 0:\\n            self.head = self.head.next\\n            \\n            if self.head == None or self.head.next == None:\\n                self.tail = self.head\\n            if self.head != None:\\n                self.head.previous = None \\n            self.length -= 1\\n            return\\n\\n        if position>=self.length:\\n            position = self.length-1\\n\\n        current_node = self.head\\n        for i in range(position - 1):\\n            current_node = current_node.next\\n        current_node.next = current_node.next.next\\n        if current_node.next != None: \\n            current_node.next.previous = current_node\\n        else:\\n            self.tail = current_node\\n        self.length -= 1\\n        return\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Linked list","date":"2021-07-26","description":"Linked list Data Structures"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Classification","date":"2021-11-03","description":"Naive Bayes, Discriminant Analysis, Logistic Regression"},"fields":{"slug":"/blog/est4/"}}},{"node":{"frontmatter":{"title":"Regression and Prediction","date":"2021-11-02","description":"REGRESSION"},"fields":{"slug":"/blog/est3/"}}},{"node":{"frontmatter":{"title":"Distribution","date":"2021-11-01","description":"Data distributions"},"fields":{"slug":"/blog/est1/"}}},{"node":{"frontmatter":{"title":"Stats Testing","date":"2021-11-01","description":"Statistical Experiments and significance testing"},"fields":{"slug":"/blog/est2/"}}},{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}}]}},"pageContext":{"slug":"/blog/dt3/","id":"ec4395c6-9ec5-5c9f-95f1-43b75dbe0d5a"}},"staticQueryHashes":["63159454"]}