{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/dt2/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"20a3fdde-bcb1-5cf9-a5b6-283e3b11a3aa","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Hash tables Data Structures\",\n  \"date\": \"2021-07-26\",\n  \"description\": \"Hash tables Data Structures\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Hash tables\"), mdx(\"p\", null, \"The Hash Table is a Data Structure in an \\\"associative\\\" way, that is, it has to associate a key with a value to perform its operations.\"), mdx(\"p\", null, \"The key is associated with the value thanks to the hash function. This function is used to calculate the index that corresponds to the value of the key that we have passed to it.\"), mdx(\"p\", null, \"This structure also has the particularity that it is one of the most efficient and fastest Data Structures, this is because its execution time is constant in the average case. The complexity of hash tables is:\"), mdx(\"center\", null, mdx(\"img\", {\n    src: \"https://i.imgur.com/PoByZvQ.png\"\n  })), mdx(\"h2\", null, \"The hash function\"), mdx(\"p\", null, \"The hash function is the most important part of the hash table since it determines the cost of this data structure.\"), mdx(\"p\", null, \"The hash function what it does with the key is to convert it so to speak into a code. This code what this function does is that when we pass the key this key is going to be passed by the function and this function is going to transform it into a reference to the memory.\"), mdx(\"p\", null, \"The hash function inside is a set of mathematical operations that unwraps the key until it can not be understood for example if we give the values \\\"hola\\\" or \\\"Hola\\\" it will give us:\"), mdx(\"center\", null, \"\\\"hola\\\"=>4d186321c1a7f0f354b297e8914ab240\"), mdx(\"center\", null, \"\\\"Hola\\\"=>f688ae26e9cfa3ba6235477831d5122e\"), mdx(\"p\", null, \"As we can see this will give a totally different value although the only difference between the 2 words is the capitalization, and these values are unique, \\\"hola\\\" and \\\"Hola\\\" will always take these values. \"), mdx(\"p\", null, \"The hash functions will almost always take a predetermined length, for example \\\"a\\\" and \\\"how are you doing bro\\\" when passed through the hash function will have the same length so there will be collisions.\"), mdx(\"p\", null, \"A characteristic of hash tables is that a computer does not take time to make it but it is very difficult to undo it so much so that. \"), mdx(\"p\", null, \"The hash table stores the elements in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"slots\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"buckets\"), \".\"), mdx(\"h2\", null, \"collision\"), mdx(\"p\", null, \"We know that most hashes have a fixed length size, this means that it can happen the situation that 2 different inputs (keys) passing through the hash function can result in the same value.\"), mdx(\"p\", null, \"It is mathematically impossible that a collision does not occur, but we can say that collisions mostly occur in bad algorithms, if an algorithm has collisions then the algorithmic complexity will vary. Let's see an example:\"), mdx(\"p\", null, \"Suppose that the hash function goes to a single reference in memory, this will gather several values let's say in an array or the a linked list so read or modify will have the algorithmic complexity of one of them.\"), mdx(\"p\", null, \"It is possible to create a collision free algorithm, this is done by being careful with the length and the amount of keys we have or the hash algorithm we are using (MD5 or some SHA algorithm).\"), mdx(\"h2\", null, \"Example\"), mdx(\"p\", null, \"In Python, the Dictionary data types represent the implementation of hash tables.\\nLet's see an example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"dict = {'Name': 'Enrique',     \\n        'Age':18,              \\n        'Gender':'male',       \\n        'Idiom': 'en',\\n        'second idiom': 'es'   \\n        }\\n\\ndict['second idiom'] # es\\n\")), mdx(\"h2\", null, \"implement\"), mdx(\"p\", null, \"althouh in some languages it works a little differently, we can implement a hash table in this way\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class hash_table():            \\n    def __init__(self,size):   \\n        self.size = size       \\n        self.data = [None]*self.size    \\n    def __str__(self):\\n        return str(self.__dict__)       \\n    def _hash(self, key):\\n        hash = 0               \\n        for i in range(len(key)):       \\n            hash = (hash + ord(key[i])*i) % self.size\\n        return hash            \\n  \\n    def set(self, key, value): \\n        hash = self._hash(key) \\n        if not self.data[hash]:         \\n            self.data[hash] = [[key,value]] \\n        else:\\n            self.data[hash].append([key, value])\\n\\n    def get(self,key):\\n        hash = self._hash(key)\\n        if self.data[hash]:\\n            for i in range(len(self.data[hash])): \\n                if self.data[hash][i][0] == key: \\n                    return self.data[hash][i][1]    \\n        return None\\n\\n\\n    def keys(self): \\n        keys_array = [] \\n        for i in range(self.size):      \\n            if self.data[i]:\\n                if len(self.data[i]) > 1:       \\n                    for j in range(len(self.data[i])):  \\n                        keys_array.append(self.data[i][j][0])\\n                else:\\n                    keys_array.append(self.data[i][0][0])\\n        return keys_array\\n\\n    def values(self): \\n        values_array = []\\n        for i in range(self.size):      \\n            if self.data[i]:\\n                for j in range(len(self.data[i])):\\n                    values_array.append(self.data[i][j][1])\\n        return values_array\\n\")), mdx(\"h2\", null, \"Pros and Cons:\"), mdx(\"h3\", null, \"Pros\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Fast\"), \": the most important advantage over hash tables is that it is fast in accessing, deleting and saving data. For this reason it is widely used in databases.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Use\"), \": is very easy to use and understand\")), mdx(\"h3\", null, \"Cons\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Collisions\"), \": the collisions can become inefficient when there are many keys in the hash tables\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"values\"), \": hash tables do not allow for all types of values (eg. NULL)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"memory\"), \": if space is reserved for all possible elements it may require more memory than needed\")), mdx(\"h2\", null, \"Example\"), mdx(\"p\", null, \"we can see a great example with a Google Interview Question:\\nGiven an array, return the first recurring character\"), mdx(\"p\", null, \"Example1 : array = \", \"[2,5,6,2,6,5,1,4]\"), mdx(\"p\", null, \"It should return 2              \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def sl(array):\\n    dictionary = dict()\\n    for item in array:\\n        if item in dictionary:\\n            return item\\n        else:\\n            dictionary[item] = True\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Hash tables Data Structures","date":"2021-07-26","description":"Hash tables Data Structures"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}},{"node":{"frontmatter":{"title":"Sorting algorithms","date":"2021-08-26","description":"Bubble sort .o0"},"fields":{"slug":"/blog/alg2/"}}},{"node":{"frontmatter":{"title":"RSA","date":"2021-08-14","description":"Modular arithmetic, cryptography"},"fields":{"slug":"/blog/RSA/"}}},{"node":{"frontmatter":{"title":"what happens when we access a webpage","date":"2021-07-26","description":"ka"},"fields":{"slug":"/blog/backend_1/"}}},{"node":{"frontmatter":{"title":"Array Data Structures","date":"2021-07-26","description":"Arrays Data Structures"},"fields":{"slug":"/blog/dt1/"}}}]}},"pageContext":{"slug":"/blog/dt2/","id":"20a3fdde-bcb1-5cf9-a5b6-283e3b11a3aa"}},"staticQueryHashes":["63159454"]}