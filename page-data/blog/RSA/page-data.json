{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/RSA/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"e00344fe-30f3-5fb5-ac2f-c037feb4adb1","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"RSA\",\n  \"date\": \"2021-08-14\",\n  \"description\": \"Modular arithmetic, cryptography\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Modular arithmetic\"), mdx(\"p\", null, \"Set an integer \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"n>1\"), \", we will refer to it as the module. Recall that any integer b can be written in a single form as \"), mdx(\"div\", {\n    \"className\": \"math\"\n  }, \"b=nq+r\"), mdx(\"p\", null, \"where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"0\\\\leq r < n\"), \" the number r is called the remainder.\"), mdx(\"p\", null, \"We say that a and b are congruent modulo n if they verify either of the two equivalent statements. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a and b give the same remainder when dividing by n. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The difference between \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"a\"), \" and \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"b\"), \" is a multiple of n, i.e.\", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"(a-b)\\\\in n\\\\Z\"), \".we write in that case \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"inlineMath\"\n  }, \"a\\\\equiv b\"), \" (mod n)\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOTES\"), \" When, for context, it is not necessary to specify the module we will simply write \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a\\\\equiv b\"), \"\\nnote that given \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"a\\\\in Z\"), \", we denote by \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\bar{a}\"), \" the remainder of dividing a by n. the set \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"{ \\\\lbrace\\\\bar{0},\\\\bar{1},...,\\\\overline{n-1}} \\\\rbrace\"), \" of all posible residues is denoted \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\Z/n\\\\Z\"), \" using this notation, it is the same to write(for example if we work module 4) \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"\\\\bar{7}=\\\\bar{3}\"), \" or \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"inlineMath\"\n  }, \"7\\\\equiv 4\"), \" Both expressions have the same meaning \"), mdx(\"h1\", null, \"Euclid's algorithm\"), mdx(\"p\", null, \"This is a way to find the d.c.m. between two integers. Moreover, it allows to write this d.c.m. as a linear combination (with integer coefficients) of these. For example, let us calculate the d.c.m. between a = 236441 and b = 45955. We consider the pair (236411, 45955) We divide the larger by the smaller, obtaining.\"), mdx(\"center\", null, \"236441 = 5 \\xD7 45955 + 6666 \"), mdx(\"p\", null, \"We then temporarily forget about the larger number, and keep the remainder as the new number. That is, we pass to the pair (45955, 6666). We perform the same operation again, dividing the small by the large, consider the new pair formed by the previous small and by the remainder:\"), mdx(\"center\", null, \"45955 = 6 \\xD7 6666 + 5959,\\xA0\\xA0\\xA0\\xA0\\xA0 (6666, 5959)\", mdx(\"p\", null, \"6666 = 1 \\xD7 5959 + 707, \", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\xA0\", \" \\t(5959, 707) \"), mdx(\"p\", null, \"5959 = 8 \\xD7 707 + 303,  \", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\t\\t(707, 303)\"), mdx(\"p\", null, \" 707 = 2 \\xD7 303 + 101,  \", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\t\\t(303, 101)\"), mdx(\"p\", null, \" 303 = 3 \\xD7 101 + 0,    \", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\xA0\", \"\\t\\t(101, 0)\")), mdx(\"p\", null, \"Terminate the process when it reaches a zero residue. The above residue is the m.c.d. i.e. m.c.d.(236411, 45955) = 2. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"RSA","date":"2021-08-14","description":"Modular arithmetic, cryptography"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Distribution","date":"2021-11-01","description":"Data distributions"},"fields":{"slug":"/blog/est1/"}}},{"node":{"frontmatter":{"title":"Stats Testing","date":"2021-11-01","description":"Statistical Experiments and significance testing"},"fields":{"slug":"/blog/est2/"}}},{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}},{"node":{"frontmatter":{"title":"Sorting algorithms","date":"2021-08-26","description":"Bubble sort .o0"},"fields":{"slug":"/blog/alg2/"}}},{"node":{"frontmatter":{"title":"Algorithms Search","date":"2021-08-26","description":"BFS & DFS"},"fields":{"slug":"/blog/alg3/"}}}]}},"pageContext":{"slug":"/blog/RSA/","id":"e00344fe-30f3-5fb5-ac2f-c037feb4adb1"}},"staticQueryHashes":["63159454"]}