{"componentChunkName":"component---src-components-blogpost-blogpost-jsx","path":"/blog/alg4/","result":{"data":{"site":{"siteMetadata":{"title":"K011"}},"mdx":{"id":"0c3fd739-ce44-5ae7-b75e-2cb12b1c77db","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dinamic Programming\",\n  \"date\": \"2021-08-26\",\n  \"description\": \"Memoization,fibonacci\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The idea of dynamic programming is to use obtained solutions to calculate the initial problem, not to calculate the same thing twice,and to normally use a table of results that is filled in as the sub-examples are solved.\\nDynamic programming is a bottom-up approach. The smallest and therefore simplest sub-examples are solved first. By combining the solutions, the solutions of successively larger specimens are obtained until the original specimen is reached.\"), mdx(\"p\", null, \"Let's see an example using memoization:\\nWhen we calculate the fibonacci using recursion for very large numbers it becomes very complex and slow. Since the same operation can be computed several times, we can see this in a graph:\"), mdx(\"center\", null, mdx(\"img\", {\n    className: \"w-80-l\",\n    src: \"https://imgur.com/OCFgpbb.png\"\n  })), mdx(\"p\", null, \"This can be optimized with dynamic programming by using memoization, i.e. making a cache which stores the operations for later use.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"f = [0, 1]\\ndef Fibonacci(n):              \\n    if len(f)>n:\\n        return f[n]\\n    else:\\n        print(f\\\"calculando fibonacci {n}\\\")\\n        f.append(Fibonacci(n-1)+Fibonacci(n-2))\\n        print(f)\\n        return Fibonacci(n-1)+Fibonacci(n-2)\\n\")), mdx(\"p\", null, \"But we see that this can be improved, because with dynamic programming in this algorithm we do not need recursion, so we use a cycle\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"\\ndef Fibonacci(n):\\n    f = [0, 1]\\n    for i in range(2, n+1):\\n        f.append(f[i-1] + f[i-2])\\n    return f[n]\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Dinamic Programming","date":"2021-08-26","description":"Memoization,fibonacci"}},"allMdx":{"edges":[{"node":{"frontmatter":{"title":"Regression and Prediction","date":"2021-11-02","description":"REGRESSION"},"fields":{"slug":"/blog/est3/"}}},{"node":{"frontmatter":{"title":"Distribution","date":"2021-11-01","description":"Data distributions"},"fields":{"slug":"/blog/est1/"}}},{"node":{"frontmatter":{"title":"Stats Testing","date":"2021-11-01","description":"Statistical Experiments and significance testing"},"fields":{"slug":"/blog/est2/"}}},{"node":{"frontmatter":{"title":"Recursion","date":"2021-08-26","description":"Algorithm recursion"},"fields":{"slug":"/blog/alg1/"}}},{"node":{"frontmatter":{"title":"Sorting algorithms","date":"2021-08-26","description":"Bubble sort .o0"},"fields":{"slug":"/blog/alg2/"}}}]}},"pageContext":{"slug":"/blog/alg4/","id":"0c3fd739-ce44-5ae7-b75e-2cb12b1c77db"}},"staticQueryHashes":["63159454"]}